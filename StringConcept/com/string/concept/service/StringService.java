package com.string.concept.service;

import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;

public class StringService {

	/**
	 * convert Roman number to Integer number
	 * 
	 * @param str
	 * @return
	 */
	public int romanToDecimal(String str) {
		
		// Double brace initialization for map
//         final Map<Character, Integer> romanDecimalMap = 
//                new HashMap() {{
//                  put('I', 1);
//                  put('V', 5);
//                  put('X', 10);
//                  put('L', 50);
//                  put('C', 100);
//                  put('D', 500);
//                  put('M', 1000);
//                }};

		final Map<Character, Integer> romanDecimalMap = new HashMap<>();

		romanDecimalMap.put('I', 1);
		romanDecimalMap.put('V', 5);
		romanDecimalMap.put('X', 10);
		romanDecimalMap.put('L', 50);
		romanDecimalMap.put('C', 100);
		romanDecimalMap.put('D', 500);
		romanDecimalMap.put('M', 1000);

		int sum = 0;

		for (int i = 0; i < str.length(); i++) {

			int num1 = romanDecimalMap.get(str.charAt(i));
			if (i + 1 < str.length()) {
				int num2 = romanDecimalMap.get(str.charAt(i + 1));

				if (num1 < num2) {
					sum += num2 - num1;
					i++;
				} else {
					sum += num1;
				}
			} else {
				sum += num1;
			}
		}

		return sum;
	}

	// we have to print first non repeating character
	// String a = "inteligence";
	public char getFirstNonRepChar(String str) {

		int[] charArr = new int[26];

		for (int i = 0; i < str.length(); i++) {
			int chValue = str.charAt(i) - 97;
			charArr[chValue] = charArr[chValue] + 1;
		}

		for (int i = 0; i < str.length(); i++) {
			int chValue = str.charAt(i) - 97;
			if (charArr[chValue] == 1) {
				return str.charAt(i);
			}
		}

		return 'n';
	}

	public String divide(int dividend, int divisor) {

		if (dividend == 0)
			return "0"; // if numerator is zero
		if (divisor == 0)
			return ""; // if denominator is zero

		// result StringBuilder

		StringBuilder result = new StringBuilder();
		if ((dividend < 0) ^ (divisor < 0))
			result.append("-"); // check -ve sign

		// absoulte values of num and den

		dividend = Math.abs(dividend);
		divisor = Math.abs(divisor);

		long quo = dividend / divisor; // Quotient
		long rem = dividend % divisor * 10; // calculating remainder

		result.append(String.valueOf(quo)); // appending quotient
		if (rem == 0)
			return result.toString(); // return if remainder is 0

		// if remainder is not zero, continue

		result.append(".");
		Map<Long, Integer> m = new HashMap<>(); // map for storing remainder
												// and the indexes of the
												// appropriate decimal in
												// stringbuilder

		while (rem != 0) {

			if (m.containsKey(rem)) {

				// if the rem is already present, find the
				// index and append ( )

				int index = m.get(rem);
				String part1 = result.substring(0, index);
				String part2 = "(" + result.substring(index, result.length()) + ")";
				return part1 + part2;
			}

			// continue updating the map and appending quo
			// which was generated by dividing rem with den

			m.put(rem, result.length());
			quo = rem / divisor;
			result.append(String.valueOf(quo));

			// update rem
			rem = (rem % divisor) * 10;
		}
		return result.toString();
	}

	public boolean isOneStringSubStringOfPermutationOfAnotherStirng(String str1, String str2, String op) {

		if (str1.isEmpty() && str2.contains(op)) {
			return true;
		}

		for (int i = 0; i < str1.length(); i++) {
			if (isOneStringSubStringOfPermutationOfAnotherStirng(str1.substring(0, i) + str1.substring(i + 1), str2,
					op + str1.charAt(i))) {
				return true;
			}
		}

		return false;
	}

	public void printAllSubString(String str) {
		for (int i = 0; i < str.length(); i++) {
			for (int j = i + 1; j <= str.length(); j++) {
				System.out.println(str.substring(i, j));
			}
		}
	}

	public int isAllAlphabetPresent(String str) {
		str = str.toLowerCase();
		int countLetter = 0;
		boolean[] visitedAlphabet = new boolean[26];
		if (str.length() < 26) {
			return 0;
		}
		for (Character ch : str.toCharArray()) {
			int index = ch - 'a';
			if (!visitedAlphabet[index]) {
				visitedAlphabet[index] = true;
				countLetter++;
				if (countLetter == 26) {
					return 1;
				}
			}
		}

		return countLetter == 26 ? 1 : 0;
	}

	public String flamesGame(String str1, String str2) {

		// If obtained value is 1, output "Friends"
		// If obtained value is 2, output "Love"
		// If obtained value is 3, output "Affection"
		// If obtained value is 4, output "Marriage"
		// If obtained value is 5, output "Enemy"
		// If obtained value is 0, output "Siblings"

		// switch (getLenthAfterRemovingCommonChar(str1, str2) % 6) {
		switch (getLenthAfterRemovingCommonChar2ndWay(str1, str2) % 6) {

		case 0:
			return "Siblings";
		case 1:
			return "Friends";
		case 2:
			return "Love";
		case 3:
			return "Affection";
		case 4:
			return "Marriage";
		case 5:
			return "Enemy";
		default:
			return null;
		}

	}

	public int getLenthAfterRemovingCommonChar2ndWay(String str1, String str2) {
		int[] alphabet = new int[26];

		int commonElements = 0;
		for (Character ch : str1.toCharArray()) {
			int index = ch - 97; // or ch - 'a';
			alphabet[index] = alphabet[index] + 1;
		}

		for (Character ch : str2.toCharArray()) {
			int index = ch - 'a';
			if (alphabet[index] > 0) {
				commonElements++;
				alphabet[index] = alphabet[index] - 1;
			}
		}

		return (str1.length() + str2.length()) - (commonElements * 2);
	}

	public int getLenthAfterRemovingCommonChar(String str1, String str2) {

		int commonElements = 0;
		Map<Character, Integer> str1Map = new HashMap<>();

		for (Character ch : str1.toCharArray()) {
			str1Map.put(ch, str1Map.getOrDefault(ch, 0) + 1);
		}

		for (Character ch : str2.toCharArray()) {
			if (str1Map.containsKey(ch)) {
				int value = str1Map.get(ch);
				if (value == 1) {
					str1Map.remove(ch);
				} else {
					str1Map.put(ch, value - 1);
				}
				commonElements++;
			}
		}

		return (str1.length() + str2.length()) - (commonElements * 2);
	}

	public String compressString(String str) {
		String compressString = new String();

		Map<Character, Integer> compressStringMap = new HashMap<>();

		// compressStringMap.put(str.charAt(0), 1);
		// for(int i = 1; i< str.length(); i++) {
		//
		// }

		for (Character ch : str.toCharArray()) {
			if (compressStringMap.containsKey(ch)) {
				compressStringMap.put(ch, compressStringMap.get(ch) + 1);
			} else if (!compressStringMap.isEmpty()) {
				Entry<Character, Integer> entry = compressStringMap.entrySet().iterator().next();
				compressString += entry.getKey().toString() + entry.getValue();
				compressStringMap.clear();
				compressStringMap.put(ch, 1);
			} else {
				compressStringMap.put(ch, 1);
			}
		}

		if (!compressStringMap.isEmpty()) {
			Entry<Character, Integer> entry = compressStringMap.entrySet().iterator().next();
			compressString += entry.getKey().toString() + entry.getValue();
		}

		return compressString;
	}

	public boolean isItDalindrome(String str) {

		for (int i = 0; i < str.length(); i++) {
			for (int j = str.length() - 1; j >= 0; j--) {
				if (str.charAt(i) == str.charAt(j) && isItPalindrome(str.substring(i, j + 1))) {
					return true;
				}
			}
		}

		return false;
	}

	public boolean isItPalindrome(String str) {

		for (int i = 0; i < str.length() / 2; i++) {
			if (str.charAt(i) != str.charAt(str.length() - i - 1)) {
				return false;
			}
		}

		return true;
	}

	public void printAllPermutation(String str, String output) {
		if (str.isEmpty()) {
			System.out.println(output);
		}

		for (int i = 0; i < str.length(); i++) {
			printAllPermutation(str.substring(0, i) + str.substring(i + 1), output + str.charAt(i));
		}
	}

	public int check2Rotation(String str1, String str2) {

		if (str2.length() == 1) {
			if (str1.equals(str2)) {
				return 1;
			}
			return 0;
		}
		String clockWise = str2.substring(str2.length() - 2) + str2.substring(0, str2.length() - 2);
		String antiClockWise = str2.substring(2) + str2.substring(0, 2);
		if (str1.equals(clockWise) || str1.equals(antiClockWise)) {
			return 1;
		}

		return 0;
	}
}
